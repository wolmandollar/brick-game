<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>브릭 브레이커 (미니)</title>
<style>
  :root{
    /* 테마 색상 – 필요 시 Adobe Color HEX로 교체하세요 */
    --bg:#0f172a;        /* 배경 */
    --fg:#e2e8f0;        /* 글자 */
    --accent:#38bdf8;    /* 포인트 */
    --brick1:#7dd3fc; --brick2:#a78bfa; --brick3:#34d399; --brick4:#f59e0b; --brick5:#ef4444;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; display:flex; flex-direction:column; align-items:center; gap:12px;
    background:radial-gradient(800px 600px at 20% 15%, rgba(56,189,248,.12), transparent 60%),
               linear-gradient(135deg, var(--bg), #0b132b 70%, #090f1c);
    color:var(--fg); font-family:system-ui,-apple-system,Segoe UI,Roboto,'Noto Sans KR',sans-serif;
    padding:18px;
  }
  header{width:100%; max-width:900px; display:flex; align-items:center; justify-content:space-between; gap:10px}
  .title{font-weight:800; letter-spacing:.2px}
  .hud{display:flex; gap:12px; font-weight:700}
  .chip{padding:6px 10px; border-radius:999px; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12)}
  .panel{width:100%; max-width:900px; display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap}
  .btn{padding:8px 12px; border-radius:10px; border:1px solid rgba(255,255,255,.15); background:rgba(255,255,255,.06); color:var(--fg); font-weight:800; cursor:pointer}
  .note{opacity:.75; font-size:13px}
  .wrap{width:100%; max-width:900px; aspect-ratio:16/9; border-radius:14px; overflow:hidden; border:1px solid rgba(255,255,255,.15); background:#0b1220}
  canvas{width:100%; height:100%; display:block; background:transparent}
  .center-msg{
    position:absolute; inset:0; display:grid; place-items:center; pointer-events:none;
    color:var(--fg); text-align:center; padding:16px; font-weight:800; text-shadow:0 2px 10px rgba(0,0,0,.4)
  }
  .hidden{display:none}
</style>
</head>
<body>
  <header>
    <div class="title">🧱 브릭 브레이커 (미니)</div>
    <div class="hud">
      <div class="chip">점수: <span id="score">0</span></div>
      <div class="chip">스테이지: <span id="stage">1</span></div>
      <div class="chip">목숨: <span id="lives">3</span></div>
    </div>
  </header>

  <section class="panel">
    <div class="note">이동: ← → 또는 A/D · 시작/일시정지: Space/클릭 · 모바일은 패들 드래그</div>
    <div>
      <button id="startBtn" class="btn">▶ 시작/일시정지</button>
      <button id="resetBtn" class="btn">⟳ 리셋</button>
    </div>
  </section>

  <div class="wrap" id="wrap" style="position:relative">
    <canvas id="game" width="900" height="506"></canvas>
    <div id="msg" class="center-msg">클릭 또는 Space로 시작!</div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const wrap = document.getElementById('wrap');
  const scoreEl = document.getElementById('score');
  const stageEl = document.getElementById('stage');
  const livesEl = document.getElementById('lives');
  const msgEl = document.getElementById('msg');

  // 게임 상태
  let running = false;
  let over = false;
  let score = 0;
  let stage = 1;
  let lives = 3;

  // 패들/공
  const paddle = { w: 110, h: 14, x: canvas.width/2-55, y: canvas.height-28, speed: 8 };
  const ball = { x: canvas.width/2, y: canvas.height-60, r: 8, vx: 4, vy: -4, speed: 5.0 };

  // 벽돌
  const rowsBase = 5, colsBase = 10, brickPad = 8, topOffset = 60, sideOffset = 26;
  let bricks = [];

  const colors = ['var(--brick1)','var(--brick2)','var(--brick3)','var(--brick4)','var(--brick5)'];

  function initStage(n){
    // 속도/행열 증가로 난이도 조절
    const rows = rowsBase + Math.floor((n-1)%3);
    const cols = colsBase + (n>2?1:0);
    const brickW = (canvas.width - sideOffset*2 - (cols-1)*brickPad) / cols;
    const brickH = 22;

    bricks = [];
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        bricks.push({
          x: sideOffset + c*(brickW+brickPad),
          y: topOffset + r*(brickH+brickPad),
          w: brickW, h: brickH,
          hp: 1 + Math.floor((n-1)/2), // 스테이지가 오를수록 체력 증가
          color: colors[r%colors.length]
        });
      }
    }

    // 패들/공 초기화
    paddle.x = canvas.width/2 - paddle.w/2;
    ball.x = canvas.width/2; ball.y = canvas.height - 60;
    const base = 4 + Math.min(4, n-1)*0.6;
    ball.vx = base * (Math.random()<0.5?-1:1);
    ball.vy = -base;
    over = false;
    draw(); // 초기 렌더
  }

  // 입력
  const keys = {};
  window.addEventListener('keydown', (e)=>{
    if(['ArrowLeft','ArrowRight','a','d','A','D',' '].includes(e.key)) e.preventDefault();
    keys[e.key] = true;
    if(e.key === ' ') toggleRun();
  });
  window.addEventListener('keyup', (e)=>{ keys[e.key] = false; });

  // 마우스/터치로 패들 이동
  let dragging = false;
  wrap.addEventListener('pointerdown', (e)=>{ dragging=true; if(!running) toggleRun(); movePaddle(e); });
  wrap.addEventListener('pointermove', (e)=>{ if(dragging) movePaddle(e); });
  wrap.addEventListener('pointerup', ()=> dragging=false);
  function movePaddle(e){
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (canvas.width/rect.width);
    paddle.x = Math.max(0, Math.min(canvas.width - paddle.w, x - paddle.w/2));
  }

  function toggleRun(){
    if(over){ // 게임오버 상태에서 누르면 리셋
      resetGame();
      return;
    }
    running = !running;
    msgEl.textContent = running ? '' : '일시정지 (Space/클릭으로 재시작)';
    msgEl.classList.toggle('hidden', running);
  }

  // 버튼
  document.getElementById('startBtn').onclick = toggleRun;
  document.getElementById('resetBtn').onclick = resetGame;

  function resetGame(){
    score = 0; stage = 1; lives = 3;
    scoreEl.textContent = score; stageEl.textContent = stage; livesEl.textContent = lives;
    initStage(stage);
    running = false; over = false;
    msgEl.textContent = '클릭 또는 Space로 시작!'; msgEl.classList.remove('hidden');
  }

  // 충돌 헬퍼
  function rectHitCircle(rx, ry, rw, rh, cx, cy, cr){
    // 원-사각 충돌 (클램프)
    const nx = Math.max(rx, Math.min(cx, rx+rw));
    const ny = Math.max(ry, Math.min(cy, ry+rh));
    const dx = cx - nx, dy = cy - ny;
    return (dx*dx + dy*dy) <= cr*cr;
  }

  function update(){
    // 입력 이동
    if(keys['ArrowLeft']||keys['a']||keys['A'])  paddle.x -= paddle.speed;
    if(keys['ArrowRight']||keys['d']||keys['D']) paddle.x += paddle.speed;
    paddle.x = Math.max(0, Math.min(canvas.width - paddle.w, paddle.x));

    // 공 이동
    ball.x += ball.vx; ball.y += ball.vy;

    // 벽 반사
    if(ball.x < ball.r){ ball.x = ball.r; ball.vx *= -1; }
    if(ball.x > canvas.width - ball.r){ ball.x = canvas.width - ball.r; ball.vx *= -1; }
    if(ball.y < ball.r){ ball.y = ball.r; ball.vy *= -1; }

    // 패들 충돌(스윗스팟 반사)
    if(rectHitCircle(paddle.x, paddle.y, paddle.w, paddle.h, ball.x, ball.y, ball.r)){
      ball.y = paddle.y - ball.r;
      const hit = (ball.x - (paddle.x + paddle.w/2)) / (paddle.w/2); // -1 ~ 1
      const speed = Math.hypot(ball.vx, ball.vy);
      const angle = hit * Math.PI/3; // 최대 ±60도
      ball.vx = speed * Math.sin(angle);
      ball.vy = -Math.abs(speed * Math.cos(angle));
    }

    // 벽돌 충돌
    for(let i=0;i<bricks.length;i++){
      const b = bricks[i];
      if(!b.hp) continue;
      if(rectHitCircle(b.x, b.y, b.w, b.h, ball.x, ball.y, ball.r)){
        // 간단한 반사: 더 강하게 맞은 축 반전
        const prevX = ball.x - ball.vx, prevY = ball.y - ball.vy;
        const hitX = prevX < b.x || prevX > b.x + b.w;
        if(hitX) ball.vx *= -1; else ball.vy *= -1;

        b.hp -= 1;
        score += 10; scoreEl.textContent = score;
        if(b.hp<=0) bricks.splice(i,1);
        break;
      }
    }

    // 바닥으로 떨어짐
    if(ball.y > canvas.height + 40){
      lives--; livesEl.textContent = lives;
      if(lives<=0){ gameOver(false); return; }
      // 공/패들만 재배치 후 일시정지
      paddle.x = canvas.width/2 - paddle.w/2;
      ball.x = canvas.width/2; ball.y = canvas.height - 60;
      ball.vx = (Math.random()<0.5?-1:1)*4; ball.vy = -4;
      running = false; msgEl.textContent = '실수는 누구나! Space/클릭으로 재도전'; msgEl.classList.remove('hidden');
    }

    // 스테이지 클리어
    if(bricks.length===0){
      stage++; stageEl.textContent = stage;
      score += 100; scoreEl.textContent = score;
      initStage(stage);
      running = false; msgEl.textContent = `스테이지 ${stage-1} 클리어! Space/클릭으로 다음 단계`; msgEl.classList.remove('hidden');
    }
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // 벽돌
    bricks.forEach(b=>{
      if(!b.hp) return;
      ctx.fillStyle = b.color;
      ctx.fillRect(b.x, b.y, b.w, b.h);
      // 테두리
      ctx.strokeStyle = 'rgba(0,0,0,.25)';
      ctx.strokeRect(b.x+0.5, b.y+0.5, b.w-1, b.h-1);
    });

    // 패들
    ctx.fillStyle = 'var(--fg)';
    ctx.fillRect(paddle.x, paddle.y, paddle.w, paddle.h);

    // 공
    ctx.beginPath();
    ctx.fillStyle = 'var(--accent)';
    ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
    ctx.fill();
  }

  function loop(){
    if(running) update();
    draw();
    request
